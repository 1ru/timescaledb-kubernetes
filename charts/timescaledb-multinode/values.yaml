dataNodes: 3

# To prevent very long names, we override the name, otherwise it would default to
# timescaledb-multinode (the name of the chart)
nameOverride: timescaledb

image:
  # Image was built from
  # https://github.com/timescale/timescaledb-docker-ha
  repository: timescaledev/timescaledb
  tag: v0.2.2-pg11-multinode
  pullPolicy: IfNotPresent

# Credentials used by PostgreSQL
credentials:
  accessNode:
    superuser: tea
  dataNode:
    superuser: coffee

# To allow finegrained control over PostgreSQL parameters and Kubernetes resources
# we create some templates that can be referenced in the topology.
# The templates are anchored and can then be referenced using their alias.
NodeTemplates:
  - &defaultAccessNodeTemplate
    replicaCount: 1
    # https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
    postgresql:
      parameters:
        max_connections: 100
        max_prepared_transactions: 150
        shared_buffers: 300MB
        work_mem: 16MB
        timescaledb.passfile: '../.pgpass'
        log_connections: 'on'
        log_line_prefix: "%t [%p]: [%c-%l] %u@%d,app=%a [%e] "
        log_min_duration_statement: '1s'
        log_statement: ddl
        log_checkpoints: 'on'
        log_lock_waits: 'on'
        # These values are set as the default data volume size
        # is small as well.
        min_wal_size: 256MB
        max_wal_size: 512MB
        temp_file_limit: 1GB
    volumes:
      pgdata:
        annotations: {}
        size: 1G
      pgwal:
        annotations: {}
        size: 1G
  - &defaultDataNodeTemplate
    replicaCount: 1
    # https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
    resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
    postgresql:
      parameters:
        max_connections: 100
        max_prepared_transactions: 150
        shared_buffers: 300MB
        work_mem: 16MB
        timescaledb.passfile: '../.pgpass'
        log_connections: 'on'
        log_line_prefix: "%t [%p]: [%c-%l] %u@%d,app=%a [%e] "
        log_min_duration_statement: '1s'
        log_statement: ddl
        log_checkpoints: 'on'
        log_lock_waits: 'on'
        # These values are set as the default data volume size
        # is small as well.
        min_wal_size: 256MB
        max_wal_size: 512MB
        temp_file_limit: 1GB
    volumes:
      pgdata:
        annotations: {}
        size: 5G

# The template aliases can be found under the key NodeTemplates
# As node configuration can be very large documents in and of themselves, and
# may require a lot of repetition, there are some default configurations that can
# be found in the NodeTemplates section of this Yaml document.
#
# The << syntax is documented here: https://yaml.org/type/merge.html, as a summary,
# by using <<: *alias we copy the profile, but we are free to override any subkey if needed.
topology:
  accessNodes:
    - <<: *defaultAccessNodeTemplate
  dataNodes:
    - <<: *defaultDataNodeTemplate
    - <<: *defaultDataNodeTemplate
    - <<: *defaultDataNodeTemplate
    ## An example of a Node configuration using the defaultProfileDataNode with specific
    ## overrides
    # - <<: *defaultProfileDataNode
    #   replicaCount: 2
    #   volumes:
    #     pgdata:
    #       annotations: {}
    #       size: 15G

# Extra custom environment variables.
env:
  LC_ALL: C.UTF-8
  LANG: C.UTF-8
  # Using /var/lib/postgresql/data is discouraged, as this is
  # a Docker Volume in many Docker images, which means the data is not actually persisted.
  PGDATA: /var/lib/postgresql/pgdata

# https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
nodeSelector: {}

# https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
tolerations: []

# https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
affinityTemplate: |
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        topologyKey: "kubernetes.io/hostname"
        labelSelector:
          matchLabels:
            app:  {{ template "timescaledb.name" . }}
            release: {{ .Release.Name | quote }}
affinity: {}

## Use an alternate scheduler, e.g. "stork".
## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
##
# schedulerName:

rbac:
  # Specifies whether RBAC resources should be created
  create: true

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:
